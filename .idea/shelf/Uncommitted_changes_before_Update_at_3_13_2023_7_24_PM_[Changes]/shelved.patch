Index: boat_simulator.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nCreated by Daniel-Iosif Trubacs for the MAC team on 8 March 2023. The purpose of this module is to create\r\na track from a given set of waypoints. To be run together with LoadWPL and LOS_guidance.\r\nThe main run of the simulator should be: update current position (by gps or ship sim) ->\r\ncheck whether current waypoint has been reached -> update current waypoint -> find heading\r\n\"\"\"\r\n\r\nimport numpy as np\r\nfrom LoadWPL import load_wpl\r\nfrom LOS_guidance import LOS_latlon\r\n\r\nclass Simulator():\r\n    def __init__(self, data_file: str, waypoints_list: np.ndarray,  current_pos: np.ndarray = None):\r\n        \"\"\" Class for simulating ship movement.\r\n\r\n        Args:\r\n            data_file: .txt file containing the list of waypoints\r\n            current_pos: current position of the boat (hopefully read by the gps) (defaults to [0,0]\r\n            waypoints_list: numpy array containing list of waypoints\r\n        \"\"\"\r\n        self.data_file = data_file\r\n        if current_pos is not None:\r\n           self.current_pos = current_pos\r\n        else:\r\n            self.current_pos = np.array([0, 0])\r\n        self.waypoints_list = load_wpl(data_file)\r\n\r\n    # a function to find the next waypoint\r\n    def next_waypoint(self, last_waypoint_reached = False, last_waypoint = None, index = None):\r\n        if last_waypoint is None:\r\n            return np.array([self.waypoints_list[0], 0])\r\n        elif last_waypoint_reached == True:\r\n              return np.array([self.waypoints_list[index+1], index+1])\r\n        else:\r\n            np.array([self.waypoints_list[index], index])\r\n\r\n    # hopefully used to read from the gps\r\n    def update_position(self) -> np.ndarray:\r\n        # update current position by reading from the gps (or ship sim) not done yet....\r\n        pass\r\n\r\n    # find the next heading\r\n    def find_heading(self, current_waypoint, next_waypoint):\r\n        return LOS_latlon(self.current_pos, current_waypoint, next_waypoint)\r\n\r\n\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boat_simulator.py b/boat_simulator.py
--- a/boat_simulator.py	
+++ b/boat_simulator.py	
@@ -1,50 +1,130 @@
 """
 Created by Daniel-Iosif Trubacs for the MAC team on 8 March 2023. The purpose of this module is to create
 a track from a given set of waypoints. To be run together with LoadWPL and LOS_guidance.
-The main run of the simulator should be: update current position (by gps or ship sim) ->
-check whether current waypoint has been reached -> update current waypoint -> find heading
+The main loop of the simulation should be:
+update current position -> check whether current waypoint has been reached ->
+update track and waypoint -> find heading -> set speed -> update current position.
 """
 
 import numpy as np
 from LoadWPL import load_wpl
-from LOS_guidance import LOS_latlon
+from LOS_guidance import LOS_latlon, call_distance
+from ShipSimCom import follow_heading, decode_response
+import serial
+
 
-class Simulator():
-    def __init__(self, data_file: str, waypoints_list: np.ndarray,  current_pos: np.ndarray = None):
+def next_item(item, array: np.ndarray):
+    """ Return the next item from a numpy array when the current item (but not index) is known. """
+    index = np.where(item == array)[0][0]
+    return array[index + 1]
+
+
+class Simulator:
+    def __init__(self, data_file: str):
         """ Class for simulating ship movement.
 
         Args:
-            data_file: .txt file containing the list of waypoints
-            current_pos: current position of the boat (hopefully read by the gps) (defaults to [0,0]
-            waypoints_list: numpy array containing list of waypoints
+            data_file: .txt file containing the list of waypoints and tracks
         """
         self.data_file = data_file
-        if current_pos is not None:
-           self.current_pos = current_pos
+        self.track_list = load_wpl(data_file)
+
+        # the current position of the boat, should be updated each time in the loop
+        self._current_pos = None
+
+        # the current speed of the boat, should be updated each time in the loop
+        self._current_speed = None
+
+        # the current serial object (used to connect to external hardware)
+        self._ser = None
+
+        # the current waypoint (next mission for the boat)
+        self._current_waypoint = None
+
+        # the current track of the boat
+        self._current_track = None
+
+        # the last waypoint for the boat (used to keep the boat on track)
+        self._last_waypoint = None
+
+        # a parameter to check whether the last object has been achieved. The main
+        # loop should run until this has been achieve
+        self._mission = False
+
+    # a function to create connection with external hardware
+    def create_connection(self, n_port: str, n_baudrate: int, n_timeout: int):
+        """Establishes serial communication with external hardware. See serial.Serial for more documentation."""
+        self._ser = serial.Serial(port=n_port, baudrate=n_baudrate, timeout=n_timeout)
+
+    def __update_position(self):
+        """ Update current position from external readings of GPS."""
+        # read current input from serial
+        ser_message = self._ser.readline()
+
+        # decode message into lat, long, speed, course, utc_time
+        out = decode_response(ser_message)
+
+        # extract lat and long
+        lat = float(out[0])
+        long = float(out[1])
+
+        # update position of the boat
+        self._current_pos = np.array([lat, long])
+
+    def __update_current_track(self):
+        """ Change current track when current waypoint becomes last waypoint in the track """
+        if self._current_track is None:
+            self._current_track = self.track_list[0]
         else:
-            self.current_pos = np.array([0, 0])
-        self.waypoints_list = load_wpl(data_file)
+            # check whether current waypoint is the last waypoint in the track
+            if self._current_waypoint == self._current_track[-1]:
+                # the index of next track in the tracks list
+                next_track_index = self.track_list.index(self._current_track)
+                # change current track to next track
+                self._current_track = self.track_list[next_track_index]
 
-    # a function to find the next waypoint
-    def next_waypoint(self, last_waypoint_reached = False, last_waypoint = None, index = None):
-        if last_waypoint is None:
-            return np.array([self.waypoints_list[0], 0])
-        elif last_waypoint_reached == True:
-              return np.array([self.waypoints_list[index+1], index+1])
+    def __update_current_waypoint(self):
+        """ Update current waypoint """
+        if self._current_waypoint is None:
+            self._current_waypoint = self._current_track[0]
         else:
-            np.array([self.waypoints_list[index], index])
+            # check whether current waypoint has been reached
+            if call_distance(self._current_waypoint, self._current_pos) < 1:
+                # last waypoint becomes current waypoint
+                self._last_waypoint = self._current_waypoint
 
-    # hopefully used to read from the gps
-    def update_position(self) -> np.ndarray:
-        # update current position by reading from the gps (or ship sim) not done yet....
-        pass
+                # the next waypoint in current track
+                self._current_waypoint = next_item(self._current_waypoint, self._current_track)
 
     # find the next heading
-    def find_heading(self, current_waypoint, next_waypoint):
-        return LOS_latlon(self.current_pos, current_waypoint, next_waypoint)
+    def find_heading(self):
+        # if the boat just started (the first waypoint has not been reached) use [0,0] as start
+        if self._last_waypoint is None:
+            return LOS_latlon(self._current_pos, np.array([0, 0]), self._current_waypoint)
+        else:
+            return LOS_latlon(self._current_pos, self._last_waypoint, self._current_waypoint)
 
+    def simulate(self):
+        """The main loop running the simulation."""
+        # create connection with the hardware
+        Simulator.create_connection(self, 'COM4', 115200, 1)
 
+        # running until the mission is achieved
+        while not self._mission:
+            # update position of the boat
+            Simulator.__update_position(self)
 
+            # update current track and waypoint
+            Simulator.__update_current_track(self)
+            Simulator.__update_current_waypoint(self)
 
+            # find the next heading for the boat
+            heading = Simulator.find_heading(self)
 
+            # implement heading in the boat (send the command to the external hardware)
+            follow_heading(heading)
 
+            # check whether the mission has finished (last waypoint has been reached)
+            if self._current_waypoint == self.track_list[-1][-1] and call_distance(self._current_waypoint,
+                                                                                   self._current_pos) < 1:
+                self._mission = True
Index: Simulator.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Simulator.py b/Simulator.py
--- a/Simulator.py	
+++ b/Simulator.py	
@@ -1,6 +1,12 @@
-
+import numpy as np
 
+def next_item(item, array: np.ndarray):
+    """ Return the next item from a numpy array when the current item (but not index) is known. """
+    index = np.where(item == array)[0][0]
+    return array[index+1]
 
 
 
-
+a = np.array([[1,1],[2,2],[3,3]])
+b = [1,1]
+print(next_item(b, a))
Index: ShipSimCom.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import serial\r\n\r\n\r\n# establish serial communication\r\nser = serial.Serial(port=\"COM4\", baudrate=115200, timeout=1)\r\n\r\n\r\ndef NMEA_CRC(msg):\r\n    \"\"\" Calculate the NMEA CRC checksum for a given message \"\"\"\r\n    #-- We don`t use the $ in the checksum\r\n    mycopy=msg[msg.find(\"$\")+1:] # 150] #99]\r\n    #-- Get the ASC of the first Char\r\n    crc = ord(mycopy[0:1])\r\n    #-- Use a loop to Xor through the string\r\n    for n in range(1,len(mycopy)): #-1):\r\n        crc = crc ^ ord(mycopy[n:n+1])\r\n        #-- Pass the data back as a HEX string\r\n    return '%X' % crc\r\n\r\n\r\ndef fwd(thrust_percent=84):\r\n    \"takes as input the desired speed in kts and sends this to the autopilot\"\r\n\r\n    cmd = f\"$CCTHD,{thrust_percent},0,0,0,0,0\" # 5kts\r\n    checksum = NMEA_CRC(cmd) # calculate checksum of desired command\r\n    full_cmd = f\"{cmd}*{checksum}\\r\\n\" # add checksum to command\r\n    ser.write(full_cmd.encode()) # write to \r\n\r\n\r\ndef follow_heading(hdg):\r\n    \"\"\"takes as input the desired heading and sets a course for that heading\"\"\"\r\n    #-----ENTER AUTO HEADING MODE--------\r\n    cmd = \"$CCAPM,7,64,0,80\"\r\n    checksum = NMEA_CRC(cmd) # calculate checksum of desired command\r\n    full_cmd = f\"{cmd}*{checksum}\\r\\n\" # add checksum to command\r\n    ser.write(full_cmd.encode()) # write to \r\n    \r\n    # ----- FOLLOW DESIRED COMMAND-------\r\n    cmd = f\"$CCHSC,{hdg}, T,,\"\r\n    checksum = NMEA_CRC(cmd)\r\n    full_cmd = f\"{cmd}*{checksum}\\r\\n\"\r\n    ser.write(full_cmd.encode())\r\n    \r\n    \r\ndef signal_updates():\r\n    cmd = \"$CCNVO,2,1.0,0,0.0,\" # navigation data output, get data out of port 2, interval between heading fixes. Turning 2 into 0 hides the data\r\n    checksum = NMEA_CRC(cmd)\r\n    full_cmd = f\"{cmd}*{checksum}\\r\\n\"\r\n    ser.write(full_cmd.encode())\r\n\r\n\r\n\r\ndef decode_response(message):\r\n    \"\"\"takes as input the message to decode and returns lat, lon, speed, course, utc_time\"\"\"\r\n    # decode the byte string to Unicode string\r\n    message = message.decode('utf-8').strip()\r\n    \r\n    # Split the message around the comma\r\n    params = message.split(',')\r\n    \r\n    message_id = params[0][1:] # get the message type\r\n\r\n    if message_id == \"GPRMC\": # if it is a GPS update\r\n        utc_time = params[1]\r\n        lat = params[3]\r\n        lat_dir = params[4]\r\n        lon = params[5]\r\n        lon_dir = params[6]\r\n        speed = params[7] # speed over ground in kts\r\n        course = params[8]\r\n        \r\n        print(f\"UTC time: {utc_time}\")\r\n        print(f\"Latitude: {lat} {lat_dir}\")\r\n        print(f\"Longitude: {lon} {lon_dir}\")\r\n        print(f\"Speed: {speed}\")\r\n        print(f\"Course: {course}\")\r\n    \r\n    # return lat, lon, speed, course, utc_time\r\n\r\nfwd()\r\nfollow_heading(140)\r\n\r\n\r\nsignal_updates()\r\n\r\nwhile True:\r\n    try:\r\n        # read a line of data from the serial port\r\n        message = ser.readline()\r\n\r\n        decode_response(message)\r\n\r\n    except KeyboardInterrupt:\r\n        # exit the loop on Ctrl-C\r\n        ser.close()\r\n        break\r\n        \r\nser.close() # close the serial port when done\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ShipSimCom.py b/ShipSimCom.py
--- a/ShipSimCom.py	
+++ b/ShipSimCom.py	
@@ -76,6 +76,7 @@
         print(f"Course: {course}")
     
     # return lat, lon, speed, course, utc_time
+    return lat, lon, speed, course, utc_time
 
 fwd()
 follow_heading(140)
Index: LoadWPL.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nCreated by Daniel-Iosif Trubacs for the MAC team on 8 March 2023. The purpose of this module is to load an\r\narray of Waypoints from .txt file.txt The data in .txt file should be in the NMEA format.\r\n\"\"\"\r\n\r\nimport numpy as np\r\n\r\n\r\ndef load_wpl(txt_file: str) -> np.ndarray:\r\n    \"\"\" Loads a series of waypoint from a .txt file.\r\n\r\n    Args:\r\n        txt_file: path to data file (waypoints must be in the NMEA format). An example of\r\n                  a waypoint is: $MMWPL,5050.710799,N,00044.755897,W,WPT 1.\r\n    Returns:\r\n        array containing the list of waypoints values\r\n    \"\"\"\r\n    # read the .txt file\r\n    f = None\r\n    try:\r\n        f = open(txt_file, 'r')\r\n    except FileNotFoundError as err:\r\n        print('File name incorrect', err)\r\n\r\n    # read the data and output a set of numpy array containing the waypoints\r\n    if f is not None:\r\n        # split into lines\r\n        lines = f.readlines()\r\n\r\n        # the array containing the waypoints\r\n        waypoints = []\r\n\r\n        # load the waypoints\r\n        for line in lines:\r\n            # check whether the command starts with '$WMPL'\r\n            line_split = line.split(',')\r\n            if line_split[0] == '$MMWPL':\r\n                # append the waypoint data (latitude and longitude)\r\n                waypoints.append([float(line_split[1]), float(line_split[3])])\r\n\r\n        # return the numpy array containing the waypoints\r\n        return np.array(waypoints)\r\n\r\n\r\nif __name__ == '__main__':\r\n    waypoints_test = load_wpl('data.txt')\r\n    print(waypoints_test)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/LoadWPL.py b/LoadWPL.py
--- a/LoadWPL.py	
+++ b/LoadWPL.py	
@@ -1,19 +1,23 @@
 """
 Created by Daniel-Iosif Trubacs for the MAC team on 8 March 2023. The purpose of this module is to load an
-array of Waypoints from .txt file.txt The data in .txt file should be in the NMEA format.
+array of Waypoints from a .txt and arrange them in different tracks. A track should be a simple numpy array
+containing the waypoints (in order) that should be followed). The data in .txt file should be in the NMEA format.
+sadoiajiodsjasiofdoisfhuioaefew
 """
 
 import numpy as np
 
 
-def load_wpl(txt_file: str) -> np.ndarray:
-    """ Loads a series of waypoint from a .txt file.
+def load_wpl(txt_file: str) -> list:
+    """ Loads a series of waypoint from a .txt file and return the track expected to be followed.
 
     Args:
         txt_file: path to data file (waypoints must be in the NMEA format). An example of
-                  a waypoint is: $MMWPL,5050.710799,N,00044.755897,W,WPT 1.
+                  a waypoint is: $MMWPL,5050.710799,N,00044.755897,W,WPT 1. The waypoints will
+                  be then arranged in different tracks according to the given commands. An example of
+                  of a set track command is: '$MMRTE,2,2,c,TRACK 1,WPT 6,WPT 7,WPT 8'
     Returns:
-        array containing the list of waypoints values
+        (n_tracks, n_waypoints, lat, lon): list containing the list of waypoints values arranged in tracks as numpy arrays
     """
     # read the .txt file
     f = None
@@ -30,18 +34,42 @@
         # the array containing the waypoints
         waypoints = []
 
+        # array containing the names of waypoints (e.g 'WPT 1')
+        #  the name of waypoints[i] is given by waypoints_name[i]
+        waypoints_name = []
+
         # load the waypoints
         for line in lines:
             # check whether the command starts with '$WMPL'
             line_split = line.split(',')
             if line_split[0] == '$MMWPL':
-                # append the waypoint data (latitude and longitude)
-                waypoints.append([float(line_split[1]), float(line_split[3])])
+                # append the waypoint data (latitude, longitude, waypoint_index)
+                waypoints.append(np.array([float(line_split[1]), float(line_split[3])]))
+                waypoints_name.append(line_split[5].strip())
+
+        # the array containing all the tracks
+        tracks = []
+
+        # go over all the tracks and extract the required waypoints
+        # load the waypoints
+        for line in lines:
+            # check whether the command starts with '$MMRTE'
+            line_split = line.split(',')
+            if line_split[0] == '$MMRTE':
+                # the current waypoints that make up the current track
+                track_wp_name = [line_split[i].strip() for i in range(len(line_split)) if line_split[i].strip()
+                                 in waypoints_name]
+
+                # the current track containing the waypoints
+                current_track = np.array([waypoints[waypoints_name.index(x)] for x in track_wp_name])
 
-        # return the numpy array containing the waypoints
-        return np.array(waypoints)
+                # add the current track to the list of tracks
+                tracks.append(current_track)
+
+        # return the numpy array containing the tracks
+        return tracks
 
 
 if __name__ == '__main__':
-    waypoints_test = load_wpl('data.txt')
-    print(waypoints_test)
+    tracks_test = load_wpl('data.txt')
+    print(tracks_test[0][0])
Index: LOS_guidance.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\nCreated by Chihiro Hirai for the MAC team on 8 March 2023. The purpose of this module is to\r\ncalculate the desired heading from current postion, previous waypoint and next waypoint\r\n\"\"\"\r\n\r\n# Line Of Sight(LOS) guidance  based on GPS(latlon) cordinate\r\nimport math\r\nimport numpy as np\r\nfrom numpy.linalg import norm\r\nfrom math import sqrt, cos, sin, atan2, pi\r\n\r\n\r\n# Convert the unit of Degree Minutes.Minutes to Degrees\r\ndef DMM_to_DEG(WP_DMM):\r\n    lat = WP_DMM[0]\r\n    lon = WP_DMM[1]\r\n    # For latitude\r\n    DMM_lat = str(lat).rjust(11, '0')\r\n    D1_lat = round(float(str(DMM_lat[0] + DMM_lat[1])))  # Degrees, first two digits\r\n    MM_lat = round(float(DMM_lat[2] + DMM_lat[3])) + round(math.modf(lat)[0], 6)  # Minutes\r\n    D2_lat = round(MM_lat / 60, 6)  # Convert minute to degrees\r\n    DEG_lat = D1_lat + D2_lat\r\n    # For longitude\r\n    DMM_lon = str(lon).rjust(12, '0')\r\n    D1_lon = round(float(str(DMM_lon[0] + DMM_lon[1] + DMM_lon[2])))  # Degrees, first three digits\r\n    MM_lon = round(float(DMM_lon[3] + DMM_lon[4])) + round(math.modf(lon)[0], 6)  # Minutes\r\n    D2_lon = round(MM_lon / 60, 6)  # Convert minute to degrees\r\n    DEG_lon = D1_lon + D2_lon\r\n    return (DEG_lat, DEG_lon)\r\n\r\n\r\ndef LOS_latlon(position: np.ndarray,\r\n               previous_waypoint: np.ndarray,\r\n               current_waypoint: np.ndarray,\r\n               los_radius: float = 15.0,\r\n               debug=False) -> np.ndarray:\r\n    \"\"\"\r\n\r\n    Args:\r\n        position: Latitude and longitude in DMM format\r\n        previous_waypoint: Latitude and longitude in DMM format\r\n        current_waypoint: Latitude and longitude in DMM format\r\n        los_radius: control parameter\r\n        debug: whether all parameter should be printed\r\n\r\n    Returns:\r\n        heading and error\r\n\r\n    \"\"\"\r\n    # changing from DMM to DEG format\r\n    position = DMM_to_DEG(position)\r\n    previous_waypoint = DMM_to_DEG(previous_waypoint)\r\n    current_waypoint = DMM_to_DEG(current_waypoint)\r\n\r\n\r\n    # TIP: you can access the position and waypoints with .x and .y accessors.\r\n    # Example: position.x\r\n    # Example: previous_waypoint.y\r\n    # Calc for distance on GPS cordinate\r\n    def latlon_meter_convertor(P):\r\n        # Set radius of earth\r\n        pole_radius = 6356752.314245  # Pole radius of earth\r\n        equator_radius = 6378137.0  # Equator radius\r\n        x = 360 / (equator_radius * math.cos(math.radians(P[0])) * 2 * np.pi)  # degree/m in X axis\r\n        y = 360 / (pole_radius * 2 * np.pi)  # degree/m in Y axis\r\n        return x, y\r\n\r\n    def cal_distance(P1, P2):\r\n        # Set radius of earth\r\n        pole_radius = 6356752.314245  # Pole radius of earth\r\n        equator_radius = 6378137.0  # Equator radius\r\n\r\n        # Convert latlon to radians\r\n        lat_P1 = math.radians(P1[0])\r\n        lon_P1 = math.radians(P1[1])\r\n        lat_P2 = math.radians(P2[0])\r\n        lon_P2 = math.radians(P2[1])\r\n\r\n        lat_difference = lat_P1 - lat_P2  # Difference of latitude\r\n        lon_difference = lon_P1 - lon_P2  # Difference of longitude\r\n        lat_average = (lat_P1 + lat_P2) / 2  # Mean latitude\r\n\r\n        e2 = (math.pow(equator_radius, 2) - math.pow(pole_radius, 2)) \\\r\n             / math.pow(equator_radius, 2)  # major eccentricity^2\r\n\r\n        w = math.sqrt(1 - e2 * math.pow(math.sin(lat_average), 2))\r\n\r\n        m = equator_radius * (1 - e2) / math.pow(w, 3)  # meridian curvature radius\r\n\r\n        n = equator_radius / w  # prime vertical curvature radius\r\n\r\n        distance = math.sqrt(math.pow(m * lat_difference, 2) \\\r\n                             + math.pow(n * lon_difference * math.cos(lat_average), 2))  # Distance,m\r\n\r\n        return distance, m * lat_difference, n * lon_difference\r\n\r\n    # ************************Main code for LOS******************************************************\r\n    # Angle of path\r\n    # alpha = atan2((current_waypoint.y-previous_waypoint.y),(current_waypoint.x-previous_waypoint.x))\r\n    alpha = atan2(cal_distance(current_waypoint, previous_waypoint)[1],\r\n                  cal_distance(current_waypoint, previous_waypoint)[2])\r\n    # Along-track distance (los_s) and cross-track error (los_e)\r\n\r\n    # los_s =((position.x-previous_waypoint.x)*cos(alpha)+(position.y-previous_waypoint.y)*sin(alpha))\r\n    los_s = ((cal_distance(position, previous_waypoint)[2]) * cos(alpha) + (\r\n    cal_distance(position, previous_waypoint)[1]) * sin(alpha))\r\n\r\n    # second_angle=atan2(position.y-previous_waypoint.y,position.x-previous_waypoint.x) + alpha\r\n    second_angle = atan2(cal_distance(position, previous_waypoint)[1],\r\n                         cal_distance(position, previous_waypoint)[2]) + alpha\r\n\r\n    # los_e = sqrt((position.x-previous_waypoint.x)**2+(position.y-previous_waypoint.y)**2)*sin(second_angle)\r\n    los_e = sqrt((cal_distance(position, previous_waypoint)[2]) ** 2 + (\r\n    cal_distance(position, previous_waypoint)[1]) ** 2) * sin(second_angle)\r\n\r\n    los_delta = 0.0  # this is correct\r\n\r\n    # Compute lookahead distance (los_delta). It is always positive\r\n    if los_radius > abs(los_e):\r\n        los_delta = sqrt(los_radius ** 2 - los_e ** 2)\r\n\r\n    # Orthogonal projection (where the blue line turns red)*****working for this\r\n    # xproj = (los_s )*cos(alpha)+previous_waypoint.x\r\n    # yproj = (los_s )*sin(alpha)+previous_waypoint.y\r\n    deg_meter_x = latlon_meter_convertor(position)[0]\r\n    deg_meter_y = latlon_meter_convertor(position)[1]\r\n\r\n    lon_proj = (los_s + los_delta) * cos(alpha) * deg_meter_x + previous_waypoint[\r\n        1]  # lon projection in degrees + lon of previousWP\r\n    lat_proj = (los_s + los_delta) * sin(alpha) * deg_meter_y + previous_waypoint[\r\n        0]  # lat projection in degrees + lat of previous WP\r\n\r\n    TargetP = (lat_proj, lon_proj)\r\n    # Heading point\r\n    # losx = xproj+(los_delta)*cos(alpha) - position.x\r\n    los_lon = cal_distance(TargetP, position)[2]\r\n\r\n    # losy = yproj+(los_delta)*sin(alpha) - position.y\r\n    los_lat = cal_distance(TargetP, position)[1]\r\n\r\n    # LOS heading(Desired heading angle)\r\n    los_heading = atan2((los_lat), (los_lon))\r\n\r\n    if los_heading < -pi:\r\n        los_heading += pi\r\n    elif los_heading > pi:\r\n        los_heading -= pi\r\n\r\n    if debug:\r\n        print('Alpha: ', alpha)\r\n        print('los_s: ', los_s)\r\n        print('los_e: ', los_e)\r\n        print('los_delta: ', los_delta)\r\n        print('lat_proj: ', lat_proj)\r\n        print('lon_proj: ', lon_proj)\r\n        print('los_lat: ', los_lat)\r\n        print('los_lon: ', los_lon)\r\n        print('los_heading: ', los_heading * 180 / pi)\r\n\r\n    # Return LOS heading angle and cross track error\r\n    return np.array([los_heading, los_e])\r\n\r\nP1 = np.array([5050.710799, 00044.755897])\r\nP2 = np.array([5050.720397, 00044.759597])\r\nP3 = np.array([5050.732397, 00044.755897])\r\n\r\n\r\nheading, error =LOS_latlon(P1, P2, P3)\r\nprint(heading, error)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/LOS_guidance.py b/LOS_guidance.py
--- a/LOS_guidance.py	
+++ b/LOS_guidance.py	
@@ -14,12 +14,14 @@
 def DMM_to_DEG(WP_DMM):
     lat = WP_DMM[0]
     lon = WP_DMM[1]
+
     # For latitude
     DMM_lat = str(lat).rjust(11, '0')
     D1_lat = round(float(str(DMM_lat[0] + DMM_lat[1])))  # Degrees, first two digits
     MM_lat = round(float(DMM_lat[2] + DMM_lat[3])) + round(math.modf(lat)[0], 6)  # Minutes
     D2_lat = round(MM_lat / 60, 6)  # Convert minute to degrees
     DEG_lat = D1_lat + D2_lat
+
     # For longitude
     DMM_lon = str(lon).rjust(12, '0')
     D1_lon = round(float(str(DMM_lon[0] + DMM_lon[1] + DMM_lon[2])))  # Degrees, first three digits
@@ -28,44 +30,7 @@
     DEG_lon = D1_lon + D2_lon
     return (DEG_lat, DEG_lon)
 
-
-def LOS_latlon(position: np.ndarray,
-               previous_waypoint: np.ndarray,
-               current_waypoint: np.ndarray,
-               los_radius: float = 15.0,
-               debug=False) -> np.ndarray:
-    """
-
-    Args:
-        position: Latitude and longitude in DMM format
-        previous_waypoint: Latitude and longitude in DMM format
-        current_waypoint: Latitude and longitude in DMM format
-        los_radius: control parameter
-        debug: whether all parameter should be printed
-
-    Returns:
-        heading and error
-
-    """
-    # changing from DMM to DEG format
-    position = DMM_to_DEG(position)
-    previous_waypoint = DMM_to_DEG(previous_waypoint)
-    current_waypoint = DMM_to_DEG(current_waypoint)
-
-
-    # TIP: you can access the position and waypoints with .x and .y accessors.
-    # Example: position.x
-    # Example: previous_waypoint.y
-    # Calc for distance on GPS cordinate
-    def latlon_meter_convertor(P):
-        # Set radius of earth
-        pole_radius = 6356752.314245  # Pole radius of earth
-        equator_radius = 6378137.0  # Equator radius
-        x = 360 / (equator_radius * math.cos(math.radians(P[0])) * 2 * np.pi)  # degree/m in X axis
-        y = 360 / (pole_radius * 2 * np.pi)  # degree/m in Y axis
-        return x, y
-
-    def cal_distance(P1, P2):
+def call_distance(P1, P2):
         # Set radius of earth
         pole_radius = 6356752.314245  # Pole radius of earth
         equator_radius = 6378137.0  # Equator radius
@@ -94,24 +59,61 @@
 
         return distance, m * lat_difference, n * lon_difference
 
+
+# TIP: you can access the position and waypoints with .x and .y accessors.
+# Example: position.x
+# Example: previous_waypoint.y
+# Calc for distance on GPS cordinate
+def latlon_meter_convertor(P):
+        # Set radius of earth
+        pole_radius = 6356752.314245  # Pole radius of earth
+        equator_radius = 6378137.0  # Equator radius
+        x = 360 / (equator_radius * math.cos(math.radians(P[0])) * 2 * np.pi)  # degree/m in X axis
+        y = 360 / (pole_radius * 2 * np.pi)  # degree/m in Y axis
+        return x, y
+
+def LOS_latlon(position: np.ndarray,
+               previous_waypoint: np.ndarray,
+               current_waypoint: np.ndarray,
+               los_radius: float = 15.0,
+               debug=False) -> np.ndarray:
+    """
+
+    Args:
+        position: Latitude and longitude in DMM format
+        previous_waypoint: Latitude and longitude in DMM format
+        current_waypoint: Latitude and longitude in DMM format
+        los_radius: control parameter
+        debug: whether all parameter should be printed
+
+    Returns:
+        heading and error
+
+    """
+    # changing from DMM to DEG format
+    position = DMM_to_DEG(position)
+    previous_waypoint = DMM_to_DEG(previous_waypoint)
+    current_waypoint = DMM_to_DEG(current_waypoint)
+
+
     # ************************Main code for LOS******************************************************
     # Angle of path
     # alpha = atan2((current_waypoint.y-previous_waypoint.y),(current_waypoint.x-previous_waypoint.x))
-    alpha = atan2(cal_distance(current_waypoint, previous_waypoint)[1],
-                  cal_distance(current_waypoint, previous_waypoint)[2])
+    alpha = atan2(call_distance(current_waypoint, previous_waypoint)[1],
+                  call_distance(current_waypoint, previous_waypoint)[2])
     # Along-track distance (los_s) and cross-track error (los_e)
 
     # los_s =((position.x-previous_waypoint.x)*cos(alpha)+(position.y-previous_waypoint.y)*sin(alpha))
-    los_s = ((cal_distance(position, previous_waypoint)[2]) * cos(alpha) + (
-    cal_distance(position, previous_waypoint)[1]) * sin(alpha))
+    los_s = ((call_distance(position, previous_waypoint)[2]) * cos(alpha) + (
+    call_distance(position, previous_waypoint)[1]) * sin(alpha))
 
     # second_angle=atan2(position.y-previous_waypoint.y,position.x-previous_waypoint.x) + alpha
-    second_angle = atan2(cal_distance(position, previous_waypoint)[1],
-                         cal_distance(position, previous_waypoint)[2]) + alpha
+    second_angle = atan2(call_distance(position, previous_waypoint)[1],
+                         call_distance(position, previous_waypoint)[2]) + alpha
 
     # los_e = sqrt((position.x-previous_waypoint.x)**2+(position.y-previous_waypoint.y)**2)*sin(second_angle)
-    los_e = sqrt((cal_distance(position, previous_waypoint)[2]) ** 2 + (
-    cal_distance(position, previous_waypoint)[1]) ** 2) * sin(second_angle)
+    los_e = sqrt((call_distance(position, previous_waypoint)[2]) ** 2 + (
+    call_distance(position, previous_waypoint)[1]) ** 2) * sin(second_angle)
 
     los_delta = 0.0  # this is correct
 
@@ -133,10 +135,10 @@
     TargetP = (lat_proj, lon_proj)
     # Heading point
     # losx = xproj+(los_delta)*cos(alpha) - position.x
-    los_lon = cal_distance(TargetP, position)[2]
+    los_lon = call_distance(TargetP, position)[2]
 
     # losy = yproj+(los_delta)*sin(alpha) - position.y
-    los_lat = cal_distance(TargetP, position)[1]
+    los_lat = call_distance(TargetP, position)[1]
 
     # LOS heading(Desired heading angle)
     los_heading = atan2((los_lat), (los_lon))
@@ -160,10 +162,11 @@
     # Return LOS heading angle and cross track error
     return np.array([los_heading, los_e])
 
-P1 = np.array([5050.710799, 00044.755897])
-P2 = np.array([5050.720397, 00044.759597])
-P3 = np.array([5050.732397, 00044.755897])
+if __name__ == '__main__':
+  P1 = np.array([5050.710799, 00044.755897])
+  P2 = np.array([5050.720397, 1044.759597])
+  P3 = np.array([5050.732397, 00044.755897])
+  wp_degress = DMM_to_DEG([5050.732397, 1044.755897])
 
 
-heading, error =LOS_latlon(P1, P2, P3)
-print(heading, error)
+
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"8054330c-2510-4def-b086-a6dad75a51a0\" name=\"Changes\" comment=\"\" />\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"2Mn2UMRMdjJ9LT7FVQrrqveBbho\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">\r\n    <property name=\"RunOnceActivity.OpenProjectViewOnStart\" value=\"true\" />\r\n    <property name=\"RunOnceActivity.ShowReadmeOnStart\" value=\"true\" />\r\n    <property name=\"WebServerToolWindowFactoryState\" value=\"false\" />\r\n  </component>\r\n  <component name=\"RunManager\">\r\n    <configuration name=\"LoadWPL\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"MAChallenge\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/LoadWPL.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Python.LoadWPL\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"8054330c-2510-4def-b086-a6dad75a51a0\" name=\"Changes\" comment=\"\" />\r\n      <created>1678389040961</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1678389040961</updated>\r\n      <workItem from=\"1678389044579\" duration=\"48000\" />\r\n    </task>\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"com.intellij.coverage.CoverageDataManagerImpl\">\r\n    <SUITE FILE_PATH=\"coverage/MAChallenge$LoadWPL.coverage\" NAME=\"LoadWPL Coverage Results\" MODIFIED=\"1678389074422\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	
+++ b/.idea/workspace.xml	
@@ -1,7 +1,17 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
+  <component name="AutoImportSettings">
+    <option name="autoReloadType" value="SELECTIVE" />
+  </component>
   <component name="ChangeListManager">
-    <list default="true" id="8054330c-2510-4def-b086-a6dad75a51a0" name="Changes" comment="" />
+    <list default="true" id="8054330c-2510-4def-b086-a6dad75a51a0" name="Changes" comment="">
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/LOS_guidance.py" beforeDir="false" afterPath="$PROJECT_DIR$/LOS_guidance.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/LoadWPL.py" beforeDir="false" afterPath="$PROJECT_DIR$/LoadWPL.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/ShipSimCom.py" beforeDir="false" afterPath="$PROJECT_DIR$/ShipSimCom.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Simulator.py" beforeDir="false" afterPath="$PROJECT_DIR$/Simulator.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/boat_simulator.py" beforeDir="false" afterPath="$PROJECT_DIR$/boat_simulator.py" afterDir="false" />
+    </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
     <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
@@ -20,8 +30,34 @@
     <property name="RunOnceActivity.OpenProjectViewOnStart" value="true" />
     <property name="RunOnceActivity.ShowReadmeOnStart" value="true" />
     <property name="WebServerToolWindowFactoryState" value="false" />
+    <property name="node.js.detected.package.eslint" value="true" />
+    <property name="node.js.detected.package.tslint" value="true" />
+    <property name="node.js.selected.package.eslint" value="(autodetect)" />
+    <property name="node.js.selected.package.tslint" value="(autodetect)" />
   </component>
-  <component name="RunManager">
+  <component name="RunManager" selected="Python.Simulator">
+    <configuration name="LOS_guidance" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
+      <module name="MAChallenge" />
+      <option name="INTERPRETER_OPTIONS" value="" />
+      <option name="PARENT_ENVS" value="true" />
+      <envs>
+        <env name="PYTHONUNBUFFERED" value="1" />
+      </envs>
+      <option name="SDK_HOME" value="" />
+      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
+      <option name="IS_MODULE_SDK" value="true" />
+      <option name="ADD_CONTENT_ROOTS" value="true" />
+      <option name="ADD_SOURCE_ROOTS" value="true" />
+      <EXTENSION ID="PythonCoverageRunConfigurationExtension" runner="coverage.py" />
+      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/LOS_guidance.py" />
+      <option name="PARAMETERS" value="" />
+      <option name="SHOW_COMMAND_LINE" value="false" />
+      <option name="EMULATE_TERMINAL" value="false" />
+      <option name="MODULE_MODE" value="false" />
+      <option name="REDIRECT_INPUT" value="false" />
+      <option name="INPUT_FILE" value="" />
+      <method v="2" />
+    </configuration>
     <configuration name="LoadWPL" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
       <module name="MAChallenge" />
       <option name="INTERPRETER_OPTIONS" value="" />
@@ -36,6 +72,72 @@
       <option name="ADD_SOURCE_ROOTS" value="true" />
       <EXTENSION ID="PythonCoverageRunConfigurationExtension" runner="coverage.py" />
       <option name="SCRIPT_NAME" value="$PROJECT_DIR$/LoadWPL.py" />
+      <option name="PARAMETERS" value="" />
+      <option name="SHOW_COMMAND_LINE" value="false" />
+      <option name="EMULATE_TERMINAL" value="false" />
+      <option name="MODULE_MODE" value="false" />
+      <option name="REDIRECT_INPUT" value="false" />
+      <option name="INPUT_FILE" value="" />
+      <method v="2" />
+    </configuration>
+    <configuration name="ShipSimCom" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
+      <module name="MAChallenge" />
+      <option name="INTERPRETER_OPTIONS" value="" />
+      <option name="PARENT_ENVS" value="true" />
+      <envs>
+        <env name="PYTHONUNBUFFERED" value="1" />
+      </envs>
+      <option name="SDK_HOME" value="" />
+      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
+      <option name="IS_MODULE_SDK" value="true" />
+      <option name="ADD_CONTENT_ROOTS" value="true" />
+      <option name="ADD_SOURCE_ROOTS" value="true" />
+      <EXTENSION ID="PythonCoverageRunConfigurationExtension" runner="coverage.py" />
+      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/ShipSimCom.py" />
+      <option name="PARAMETERS" value="" />
+      <option name="SHOW_COMMAND_LINE" value="false" />
+      <option name="EMULATE_TERMINAL" value="false" />
+      <option name="MODULE_MODE" value="false" />
+      <option name="REDIRECT_INPUT" value="false" />
+      <option name="INPUT_FILE" value="" />
+      <method v="2" />
+    </configuration>
+    <configuration name="Simulator" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
+      <module name="MAChallenge" />
+      <option name="INTERPRETER_OPTIONS" value="" />
+      <option name="PARENT_ENVS" value="true" />
+      <envs>
+        <env name="PYTHONUNBUFFERED" value="1" />
+      </envs>
+      <option name="SDK_HOME" value="" />
+      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
+      <option name="IS_MODULE_SDK" value="true" />
+      <option name="ADD_CONTENT_ROOTS" value="true" />
+      <option name="ADD_SOURCE_ROOTS" value="true" />
+      <EXTENSION ID="PythonCoverageRunConfigurationExtension" runner="coverage.py" />
+      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/Simulator.py" />
+      <option name="PARAMETERS" value="" />
+      <option name="SHOW_COMMAND_LINE" value="false" />
+      <option name="EMULATE_TERMINAL" value="false" />
+      <option name="MODULE_MODE" value="false" />
+      <option name="REDIRECT_INPUT" value="false" />
+      <option name="INPUT_FILE" value="" />
+      <method v="2" />
+    </configuration>
+    <configuration name="boat_simulator" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
+      <module name="MAChallenge" />
+      <option name="INTERPRETER_OPTIONS" value="" />
+      <option name="PARENT_ENVS" value="true" />
+      <envs>
+        <env name="PYTHONUNBUFFERED" value="1" />
+      </envs>
+      <option name="SDK_HOME" value="" />
+      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
+      <option name="IS_MODULE_SDK" value="true" />
+      <option name="ADD_CONTENT_ROOTS" value="true" />
+      <option name="ADD_SOURCE_ROOTS" value="true" />
+      <EXTENSION ID="PythonCoverageRunConfigurationExtension" runner="coverage.py" />
+      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/boat_simulator.py" />
       <option name="PARAMETERS" value="" />
       <option name="SHOW_COMMAND_LINE" value="false" />
       <option name="EMULATE_TERMINAL" value="false" />
@@ -46,7 +148,11 @@
     </configuration>
     <recent_temporary>
       <list>
+        <item itemvalue="Python.Simulator" />
         <item itemvalue="Python.LoadWPL" />
+        <item itemvalue="Python.ShipSimCom" />
+        <item itemvalue="Python.LOS_guidance" />
+        <item itemvalue="Python.boat_simulator" />
       </list>
     </recent_temporary>
   </component>
@@ -59,13 +165,34 @@
       <option name="presentableId" value="Default" />
       <updated>1678389040961</updated>
       <workItem from="1678389044579" duration="48000" />
+      <workItem from="1678473657552" duration="28000" />
+      <workItem from="1678530610870" duration="11291000" />
     </task>
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
     <option name="version" value="3" />
   </component>
+  <component name="Vcs.Log.Tabs.Properties">
+    <option name="TAB_STATES">
+      <map>
+        <entry key="MAIN">
+          <value>
+            <State />
+          </value>
+        </entry>
+      </map>
+    </option>
+  </component>
+  <component name="VcsManagerConfiguration">
+    <option name="LAST_COMMIT_MESSAGE" value="" />
+  </component>
   <component name="com.intellij.coverage.CoverageDataManagerImpl">
+    <SUITE FILE_PATH="coverage/Simulator_py$boat_simulator.coverage" NAME="boat_simulator Coverage Results" MODIFIED="1678543571478" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
+    <SUITE FILE_PATH="coverage/Simulator_py$ShipSimCom.coverage" NAME="ShipSimCom Coverage Results" MODIFIED="1678543652387" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
+    <SUITE FILE_PATH="coverage/Simulator_py$LoadWPL.coverage" NAME="LoadWPL Coverage Results" MODIFIED="1678543667662" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
+    <SUITE FILE_PATH="coverage/Simulator_py$Simulator.coverage" NAME="Simulator Coverage Results" MODIFIED="1678544115857" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
     <SUITE FILE_PATH="coverage/MAChallenge$LoadWPL.coverage" NAME="LoadWPL Coverage Results" MODIFIED="1678389074422" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
+    <SUITE FILE_PATH="coverage/Simulator_py$LOS_guidance.coverage" NAME="LOS_guidance Coverage Results" MODIFIED="1678543632551" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
   </component>
 </project>
\ No newline at end of file
